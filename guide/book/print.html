<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The lovm2 Guide</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="setup.html"><strong aria-hidden="true">1.1.</strong> Setup</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/introduction.html"><strong aria-hidden="true">2.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/bytecode.html"><strong aria-hidden="true">2.1.</strong> Bytecode</a></li><li class="chapter-item expanded "><a href="concepts/modules.html"><strong aria-hidden="true">2.2.</strong> Modules</a></li><li class="chapter-item expanded "><a href="concepts/types.html"><strong aria-hidden="true">2.3.</strong> Types</a></li></ol></li><li class="chapter-item expanded "><a href="building/introduction.html"><strong aria-hidden="true">3.</strong> Building Programs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="building/expressions.html"><strong aria-hidden="true">3.1.</strong> Expressions</a></li><li class="chapter-item expanded "><a href="building/assign.html"><strong aria-hidden="true">3.2.</strong> Assignment</a></li><li class="chapter-item expanded "><a href="building/branch.html"><strong aria-hidden="true">3.3.</strong> Branching</a></li><li class="chapter-item expanded "><a href="building/repeat.html"><strong aria-hidden="true">3.4.</strong> Repeating</a></li><li class="chapter-item expanded "><a href="building/iterators.html"><strong aria-hidden="true">3.5.</strong> Iterators</a></li><li class="chapter-item expanded "><a href="building/optimization.html"><strong aria-hidden="true">3.6.</strong> Optimization</a></li></ol></li><li class="chapter-item expanded "><a href="vm/introduction.html"><strong aria-hidden="true">4.</strong> Virtual Machine</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vm/context.html"><strong aria-hidden="true">4.1.</strong> Context</a></li><li class="chapter-item expanded "><a href="vm/hooks.html"><strong aria-hidden="true">4.2.</strong> Hooks</a></li><li class="chapter-item expanded "><a href="vm/interrupt.html"><strong aria-hidden="true">4.3.</strong> Interrupt</a></li></ol></li><li class="chapter-item expanded "><a href="examples/overview.html"><strong aria-hidden="true">5.</strong> Examples</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The lovm2 Guide</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<p>Dynamic languages such as Python are built on top of an interpreter that is able to understand a broad variety of bytecode instructions allowing them to replicate algorithms and process data. This design makes programs based on interpreter languages well-suited for platform independency and allows fast iterations in development.</p>
<p><code>lovm2</code> - <em>love em too</em> - is a small language building framework written in Rust featuring a dead-simple stack-based virtual machine doing exactly that. Furthermore, it comes with tools for generating said bytecode out of the box allowing you to rapidly prototype your own coding language without a hassle. There are no advanced concepts to care about. No polymorphism, closures, asynchronous runtime... just straightforward functions, variables and data structures.</p>
<p>The static <code>lovm2</code> library is so tiny that compiling it into your language yields almost no overhead and also makes it applicable for usage inside a Python environment via <a href="https://github.com/lausek/lovm2/tree/master/pylovm2">pylovm2</a>.</p>
<p>The project is in an early development stage and no API is stable yet. Feel free to <a href="https://github.com/lausek/lovm2/issues">contribute</a>.</p>
<h1><a class="header" href="#setup" id="setup">Setup</a></h1>
<ol>
<li>
<p>Modify your <code>Cargo.toml</code></p>
<ul>
<li>Add the latest crates.io version</li>
</ul>
<pre><code class="language-toml">lovm2 = &quot;0.4.8&quot;
</code></pre>
<ul>
<li>... or - if you feel lucky - use the current master branch directly</li>
</ul>
<pre><code class="language-toml">lovm2 = { git = &quot;https://github.com/lausek/lovm2&quot; }
</code></pre>
</li>
<li>
<p>Run <code>cargo update</code> on your terminal</p>
</li>
<li>
<p>Import the useful <code>lovm2</code> components into scope using <code>use lovm2::prelude::*;</code></p>
</li>
</ol>
<h1><a class="header" href="#concepts" id="concepts">Concepts</a></h1>
<p>This chapter aims to give you a brief overview of the internal workings. Even though <code>lovm2</code> is designed to be as simple as possible, it is still quite important to grasp the implementation concepts behind it.</p>
<p>The general steps of coming to a runnable program are roughly:</p>
<ul>
<li>Create a new <code>ModuleBuilder</code> and populate it with functions aka. <code>HIR</code> data</li>
<li>Call <code>module_builder.build()</code> returning a runnable <code>Module</code> from the current state</li>
<li>Load the module into an instance of a virtual machine <code>Vm</code> using <code>add_main_module()</code></li>
<li>Start the program by calling <code>run</code> on the virtual machine</li>
</ul>
<h1><a class="header" href="#bytecode" id="bytecode">Bytecode</a></h1>
<p><code>lovm2</code> is centered around the value stack. This is where the actual computation happens, parameters are passed to functions and data is shared with interrupts. There are instructions that put values on top of the stack like <code>CPush</code>, <code>LPush</code>, and <code>GPush</code>. Some just take a value off and store it somewhere like <code>LMove</code>, <code>GMove</code>. Almost all other instructions will take a given amount of values from it and leave a return value in place.</p>
<p>For example, the term <code>1 + (2 * 3)</code> will be compiled to this sequence:</p>
<pre><code class="language-bytecode"> instruction    | stack
----------------------------
 CPush          | [1]
 CPush          | [1, 2]
 CPush          | [1, 2, 3]
 Mul            | [1, 6]
 Add            | [7]
</code></pre>
<p>You do not need to micromanage the bytecode itself. There are common language constructs with which you can built pretty much everything. These constructs are composed on a function level as <code>HIR</code> so every new function gets its own <strong>h</strong>igh-level <strong>i</strong>ntermediate <strong>r</strong>epresentation. Below you can see the transformation process of a function into a runnable <code>CodeObject</code> where each arrow means &quot;lowering&quot; to the next level.</p>
<pre><code>HIR -&gt; LIR -&gt; CodeObject
</code></pre>
<p><code>LIR</code> or <strong>l</strong>ow-level <strong>i</strong>ntermediate <strong>r</strong>epresentation is not directly exposed to the user but it is quite crucial if you want to understand how the bytecode generator works under the hood.</p>
<p><code>CodeObject</code>'s on their own are already valid programs, but - as usual in every language - functions can be bundled together and exposed to the virtual machine in a collection called <code>Module</code>.</p>
<pre><code>HIR -&gt; LIR 
            \
HIR -&gt; LIR    -&gt; CodeObject -&gt; Module
            /
HIR -&gt; LIR 
</code></pre>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<p>While you are already familiar with the &quot;lovm2 native&quot; representation of executable code, <code>Modules</code> are far more abstract under the hood. <code>lovm2</code> is able to load specifically compiled shared objects at runtime and execute real native functions as well.</p>
<p>And that's not all. As long as your structure implements the <code>CallProtocol</code> trait you are free to even implement native functions inside your own compiler.</p>
<h2><a class="header" href="#shared-libraries" id="shared-libraries">Shared Libraries</a></h2>
<p>You can use <a href="concepts/..">lovm2_extend</a> to write your own modules in Rust.</p>
<h1><a class="header" href="#types" id="types">Types</a></h1>
<p><code>lovm2</code> embraces dynamic typing. The most basic ones are <code>Bool</code>, <code>Int</code>, <code>Float</code>, <code>String</code>.</p>
<p><code>Nil</code> is the default return type of functions that do not have return values. You can also use it to mark the absence of a value.</p>
<p><code>Ref</code> can wrap any other value and implement a shared mutable location as such.</p>
<h2><a class="header" href="#complex-types" id="complex-types">Complex Types</a></h2>
<p><code>List</code> and <code>Dict</code> are a bit more complicated, because they need to store other values. As such, they support the  <code>contains</code>, <code>len</code>, <code>get</code>, <code>set</code> and <code>delete</code> methods.</p>
<p>These types also utilize <code>Ref</code> heavily. If you use the standard <code>lovm2</code> functionality for generating programs, you will always implicitly work with a <code>Ref</code> to the corresponding data. The virtual machine also ensures that every value being stored inside these types is itself wrapped up in a reference. This is required for the implementation of slices. The <code>Box</code> instruction realizes this functionality.</p>
<p>Another special value kind is <code>Any</code>. This type is used for allowing external shared object modules to pass their custom Rust structures into the VM.</p>
<h2><a class="header" href="#conversion" id="conversion">Conversion</a></h2>
<p>The <code>Conv</code> instruction is able to convert data according to the following rules:</p>
<table><thead><tr><th align="center">from / to</th><th align="center">Nil</th><th align="center">Bool</th><th align="center">Int</th><th align="center">Float</th><th align="center">String</th><th align="center">List</th><th align="center">Dict</th><th align="center">Ref</th></tr></thead><tbody>
<tr><td align="center">Nil</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center">Bool</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center">Int</td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center">Float</td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center">String</td><td align="center"></td><td align="center"></td><td align="center">~</td><td align="center">~</td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center">List</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center">✓</td><td align="center"></td><td align="center"></td></tr>
<tr><td align="center">Dict</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center">✓</td><td align="center"></td></tr>
<tr><td align="center">Ref</td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✓</td><td align="center"></td><td align="center"></td><td align="center">✓</td></tr>
</tbody></table>
<p><em>~: implies parsing overhead</em></p>
<h1><a class="header" href="#building-programs" id="building-programs">Building Programs</a></h1>
<p>This chapter will show you how to utilize the <code>gen</code> module in order to compile your own <code>lovm2</code> programs. It is also possible to persist compiled modules onto your disk and load them later.</p>
<pre><pre class="playground"><code class="language-rust no_run">use lovm2::prelude::*;

<span class="boring">fn main() {
</span>let mut builder = ModuleBuilder::new();

// creates the entry point `HIR` and returns a mutable reference.
// this is actually a shortcut for builder.add(ENTRY_POINT)
let main_hir = builder.entry();

// modify `main_hir` with statements
// if in doubt, just call the `step` method and pass it the hir element
main_hir.step(Interrupt::new(10));

let module = builder.build().except(&quot;compile error&quot;);
println!(&quot;{}&quot;, module);
<span class="boring">}
</span></code></pre></pre>
<p>The main generation functionality is exposed via <code>Block</code> and every structure that contains it like <code>Branch</code>, <code>Repeat</code> and functions. You can use these methods on all of them:</p>
<ul>
<li><code>step(..)</code> append a new statement to the block.</li>
<li><code>branch()</code> create a new branch at the current position. This returns a <code>BranchBuilder</code>.</li>
<li><code>repeat()</code> and <code>repeat_until(..)</code> which return a mutable reference to a new block. The first variant is an endless loop, while the latter supports breaking once a condition is met.</li>
</ul>
<h2><a class="header" href="#functions" id="functions">Functions</a></h2>
<p>The whole <code>ModuleBuilder</code> is centered around the creation of <code>HIR</code>. As we already found out in the <a href="building/../concepts/bytecode.html">Concepts</a> chapter, a <code>HIR</code> is conceptually equal to a function. The resulting bytecode is able to process a given amount of parameters and leave a return value in place.</p>
<p>As you can see in this example listing, you should not need to create such data manually as there is functionality for adding it to the builder directly.</p>
<pre><pre class="playground"><code class="language-rust no_run">use lovm2::prelude::*;

<span class="boring">fn main() {
</span>// creates a hir with no arguments
let fn_no_args = builder.add(&quot;fn1&quot;);

// creates a hir that expects parameter n
let fn_with_args = builder.add_with_args(&quot;fn2&quot;, &amp;[lv2_var!(n)]);
<span class="boring">}
</span></code></pre></pre>
<p>To return from function, add a <code>Return::value(expr)</code> to the hir specifying the returned value or <code>Return::nil()</code> if no value is produced.</p>
<p>Due to the convention that every function has to return a value, an implicit <code>Return::nil()</code> is appended if the last instruction is not a return already.</p>
<h2><a class="header" href="#helper-macros" id="helper-macros">Helper Macros</a></h2>
<p>There are a bunch of macros inside the prelude that trivialize creating more complicated <code>lovm2</code> constructs for developers.</p>
<ul>
<li><code>lv2_var!(ident, ...)</code> turns all the identifiers given into the special type <code>Variable</code> which is needed basically everywhere. If more than one ident is declared, this returns a tuple.</li>
<li><code>lv2_dict!(ident =&gt; expr, ...)</code> creates an <code>Expr</code> that will dynamically initialize a dictionary with the key-values pairs specified.</li>
<li><code>lv2_list!(item, ...)</code> creates an <code>Expr</code> that initializes a list dynamically.</li>
<li><code>lv2_call!(ident, ... args)</code> syntactic sugar for the <code>Call</code> element.</li>
<li><code>lv2_access!(ident, ... keys)</code> syntactic sugar for the <code>Access</code> element.</li>
</ul>
<h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<p>The <code>Expr</code> represents any computation that leads to a new value on the stack. Expressions can be nested arbitrarily.</p>
<p>To give you an overview of what an expression could look like, here is the stripped down version of its actual implementation.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum Expr {
    // a constant value
    Value,
    // variable in read position
    Variable,
    // call to a function
    Call,
    // operations with one operand
    Operation1,
    // operations with two operands
    Operation2,
    // result of a type conversion
    Conv,
    // attribute read on a list or dict
    Access,
    // special variant for creating lists and dicts
    DynamicValue,
    // create a mutable subpart of a list
    Slice,
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#resolvement-of-variables" id="resolvement-of-variables">Resolvement of Variables</a></h2>
<p>While lowering, the runtime keeps track of locally assigned identifiers. This is crucial for determining the scope during read access later. If a variable is not known locally, a fallback to global scope happens.</p>
<p><code>Expr</code> variants relying on this functionality are <code>Variable</code> and <code>Access</code>. As such, their macro helper functions <code>lv2_var!</code> and <code>lv2_access!</code> follow the same rules.</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>We want to transform the formula <code>(1 + 2) * f(2)</code> to <code>lovm2</code> bytecode. Use a parser of your choice to generate an abstract syntax tree from the textual representation. Note that <code>lovm2</code> does not care about operator priorities so its your parsers duty to correctly handle them. After processing the input, your ast should look something like this:</p>
<pre><code>Value(1)
        \
         -- Operation(+)
        /               \
Value(2)                 -- Operation(*)
                        / 
              Call(f, 2)
</code></pre>
<p>And here is the compiletime representation of said formula. As you can see, every operation has an equivalent static method on <code>Expr</code>. Also note that calling a function has its own construct. This is due to calls being allowed in statement position as well.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let formula = Expr::mul(
    Expr::add(1, 2),
    Call::new(&quot;f&quot;).arg(2),
);
<span class="boring">}
</span></code></pre></pre>
<p>The (unoptimized) <code>LIR</code> now looks like this:</p>
<pre><code class="language-lir">CPush(1)
CPush(2)
Operator2(Add)
CPush(2)
Call(f, 1)
Operator2(Mul)
</code></pre>
<h1><a class="header" href="#assignment" id="assignment">Assignment</a></h1>
<p>Whenever a function is called, the call stack is adjusted guaranteeing that no local variables will interfere each other. To create or change a local variable, it is sufficient to use this construct:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Assign::local(&amp;lv2_var!(n), expr)
<span class="boring">}
</span></code></pre></pre>
<p>It is possible to store data in the global scope allowing values to live across function calls. This requires usage of the following assignment variant:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Assign::global(&amp;lv2_var!(n), expr)
<span class="boring">}
</span></code></pre></pre>
<p><code>Assign::increment(n)</code> and <code>Assign::decrement(n)</code> are also quite handy for updating variable values.</p>
<p>There is even a way of setting the values on lists and dictionaries. Under the hood, <code>Set</code> is actually expecting a <code>Ref</code> as the target location - which is retrieved by <code>Access</code> - and overwrites the value inside. This is compatible with the way dictionaries and lists are internally constructed.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Assign::local(&amp;lv2_var!(point), lv2_dict!());
Assign::set(&amp;lv2_access!(point, x), x_coord);
Assign::set(&amp;lv2_access!(point, y), y_coord);
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#branching" id="branching">Branching</a></h1>
<p>While working on your functions hir, you can call the <code>.branch()</code> method to create a point of conditional execution. A branch can have several conditions with associated blocks and at most one default condition that is always met. Branches with just a <code>default_condition</code> are not allowed.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let main_hir = builder.entry();

// ...

let equal_check = main_hir.branch();

equal_check
    .add_condition(expr)
    .step(...);

equal_check
    .default_condition()
    .step(...);
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#example-1" id="example-1">Example</a></h2>
<p>Let's implement a function that returns <em>1</em> if the given value is equal to 2 and <em>0</em> otherwise. From a Rust perspective, we could generate the function like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let main = builder.add_with_args(&quot;is_2&quot;, vec![n.clone()]);
let branch = main.branch();

branch
    .add_condition(Expr::eq(n, 2))
    .step(Return::value(1));

branch
    .default_condition()
    .step(Return::value(0));
<span class="boring">}
</span></code></pre></pre>
<p>The representation will be translated temporarily to the following optimized LIR. As you can see, a lot of labels (prefixed with a <code>.</code>) got involved right now. Everything between <code>.cond_0</code>'s start and end label is derived from our first conditions predicate and body. The <code>JumpIfFalse</code> instruction separates them by making sure that the body will be skipped if the expression evaluates to false. As usual, whenever we hit a return instruction, the function will terminate assuring that we will not fall through into our default branch.</p>
<pre><code class="language-lir">is_2:
	StoreLocal(n)
.branch_0_start:
.cond_0_start:
	PushLocal(n)
	CPush(2)
	Operator2(Equal)
	JumpIfFalse(.cond_0_end)
	CPush(1)
	Ret
.cond_0_end:
	CPush(0)
	Ret
</code></pre>
<p>In the last lowering step, there are only two things left to do: resolving label offsets and patching them into the jump instructions.</p>
<h1><a class="header" href="#repeating" id="repeating">Repeating</a></h1>
<p>Loops can be created inside blocks using the <code>.repeat()</code> and <code>.repeat_until(..)</code> methods.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let main_hir = builder.entry();

let repeat_endless = main_hir.repeat();

// run until the condition is true
let repeat_until = main_hir.repeat_until(expr);
<span class="boring">}
</span></code></pre></pre>
<p>To avoid namespace collissions in Rust, there is no <code>while</code> construct but you can simply create it via <code>.repeat_until(Expr::not(..))</code>. The optimizer makes sure that no instruction overhead is generated.</p>
<p>Inside loop blocks you are free to use <code>Break</code> and <code>Continue</code> to precisely control the flow. As in every programming language, <code>Break</code> terminates the loop while <code>Continue</code> jumps to its start again. </p>
<p>The <code>.repeat_iterating(collection, item)</code> constructor is able to consecutively assign every entity to the variable passed as <code>item</code> as long as the <code>collection</code> value supports iteration. Check the <a href="building/./iterators.html">Iterators</a> chapter if you want to find out more about this.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// repeat for all items in an iterator, assign item to variable `i`
let repeat_iterating = main_hir.repeat_iterating(lv2_list!(1, 2, 3), lv2_var!(i));

// ... and this is the elaborate variant
let it = Iter::create(lv2_list!(1, 2, 3));
let repeat_iterating = main_hir.repeat_iterating(it, lv2_var!(i));
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#example-2" id="example-2">Example</a></h2>
<p>We want to print the odd numbers between 0 and 10. This is an unbeautified implementation in pythonic pseudocode.</p>
<pre><code class="language-python">i = 0
while True:
    if i == 10:
        break
    i += 1
    if i % 2 == 0:
        continue
    print(i)
</code></pre>
<p>Translating it to <code>HIR</code> one by one could look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let i = &amp;lv2_var!(i);

// i = 0
main_hir.step(Assign::local(i, 0));

let repeat = main_hir.repeat();

// if i == 10: break
repeat
    .branch()
    .add_condition(Expr::eq(i, 10))
    .step(Break::new());

// i += 1
repeat.step(Assign::increment(i));

// if i % 2 == 0: continue
repeat
    .branch()
    .add_condition(Expr::eq(Expr::rem(i, 2), 0))
    .step(Continue::new());

// print(i)
repeat.step(lv2_call!(print, i, &quot;\n&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>You can imagine that the resulting <code>LIR</code> is a lot more elaborate than the previous examples so we will only focus on the essential parts. From a intermediate perspective an endless loop is implemented by appending an unconditional jump to the loops body.</p>
<pre><code class="language-lir">main:
.rep_0_start:
    ...
	Jump(.rep_0_start)
.rep_0_end:
</code></pre>
<p>To terminate the loop once the counter variable reaches 10, we add a conditional break to the body. This is solely a jump targeting the loops end label.</p>
<pre><code class="language-lir">.cond_0_start:
	PushLocal(i)
	CPush(10)
	Operator2(Equal)
	JumpIfFalse(.cond_0_end)
	Jump(.rep_0_end)
.cond_0_end:
</code></pre>
<p>On the other hand <code>Continue</code> targets the start label.</p>
<h1><a class="header" href="#iterators" id="iterators">Iterators</a></h1>
<p>Iterators are special values that are used to step through the items of <code>Str</code>, <code>List</code> and <code>Dict</code>. Creating them from a <code>HIR</code> perspective is as easy as passing the source expression into <code>Iter::create(..)</code>. Depending on the base collection, the return type of <code>Iter::next(..)</code> will change:</p>
<ul>
<li><code>Str</code>: Characters of the string.</li>
<li><code>Dict</code>: A <code>List</code> in which the first item is the <code>key</code> and the second item is the <code>value</code>.</li>
</ul>
<p>Only <code>List</code> causes the iterator to return a contained value as is.</p>
<h2><a class="header" href="#ranges" id="ranges">Ranges</a></h2>
<p>You can also use <code>Iter::create_ranged(from, to)</code> if you want to have a sequence of numbers.  Note that <code>from</code> is inclusive and <code>to</code> is exclusive.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let it1 = Iter::create_ranged(0, 5);
// =&gt; [0, 1, 2, 3, 4]

let it2 = Iter::create_ranged(-5, 5);
// =&gt; [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]

// passing an iterator expression into `Iter::reverse` does 
// exactly what you would expect

let it3 = Iter::reverse(Iter::create_ranged(0, 5));
// =&gt; [4, 3, 2, 1, 0]

// you can also omit `from` and `to` by passing a `Nil` value

let it4 = Iter::create_ranged(Value::Nil, 5)
// =&gt; [0, 1, 2, 3, 4]

let it5 = Iter::create_ranged(10, Value::Nil)
// =&gt; [10, 11, 12, ...]
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#example-3" id="example-3">Example</a></h2>
<p>If you want to control the iterator more granularly, feel free to use <code>Iter::has_next(it)</code> and <code>Iter::next(it)</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (it, item) = &amp;lv2_var!(it, item);

main_hir.step(Assign::local(it, Iter::create(lv2_list!(1, 2, 3, 4))));

main_hir
    .repeat_until(Expr::not(Iter::has_next(it)))
    .step(Assign::local(item, Iter::next(it)));
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#optimization" id="optimization">Optimization</a></h1>
<p>A rudimentary bytecode optimizer is enabled by default. It acts upon the generated <code>LIR</code>. If you want to disable optimization at all, use the method <code>build_with_options</code> and set the attribute <code>optimize</code> to false.</p>
<p><code>lovm2</code> gives you a guarantee that your <code>HIR</code> will not be unexpectedly altered when lowering.</p>
<h2><a class="header" href="#dead-code-elimination" id="dead-code-elimination">Dead Code elimination</a></h2>
<p>After lowering the <code>LIR</code>, the optimizer will eliminate code that is not reachable.</p>
<pre><code class="language-lir">main:               
    CPush(0)        main:
    Ret        =&gt;       CPush(0)
    CPush(1)            Ret
    ...
</code></pre>
<h2><a class="header" href="#constant-evaluation" id="constant-evaluation">Constant evaluation</a></h2>
<p>Computing constant operations ahead can not only improve the programs performance, but also drop certain constants out of the <code>CodeObject</code> overall therefore reducing its size. Bytecode sequences like will be tranformed like this:</p>
<pre><code class="language-bytecode">CPush(0)
CPush(1)   =&gt;   CPush(2)
Add
</code></pre>
<blockquote>
<p><strong>Note:</strong> The optimizer currently only optimizes expressions if all operands are constant and does not cover neutral elements like <code>+ 0</code> or <code>* 1</code> as such.</p>
</blockquote>
<h2><a class="header" href="#logical-short-curcuit" id="logical-short-curcuit">Logical short-curcuit</a></h2>
<p>It is common for languages to avoid evaluating the second operand of <code>Or</code>/<code>And</code> operations if the first term is already sufficient for the expressions outcome.</p>
<h2><a class="header" href="#small-adjustments" id="small-adjustments">Small adjustments</a></h2>
<p>The optimizer will merge instruction sequences like this:</p>
<pre><code class="language-bytecode">...
Not   =&gt;   Jt
Jt
</code></pre>
<h1><a class="header" href="#virtual-machine" id="virtual-machine">Virtual Machine</a></h1>
<p>The virtual machine is the heart of <code>lovm2</code> projects and thrives computation forward. It maintains the whole program state inside a <code>Context</code> and shares said data with every function and module interested in it.</p>
<h1><a class="header" href="#context" id="context">Context</a></h1>
<p>The context stores the programs state.</p>
<pre><pre class="playground"><code class="language-rust no_run">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Context {
    /// the module that will be run first
    pub entry: Option&lt;Rc&lt;dyn CallProtocol&gt;&gt;,
    /// available functions
    scope: HashMap&lt;Variable, CallableRef&gt;,
    /// global variables
    globals: HashMap&lt;Variable, Value&gt;,
    /// call stack with local variables
    lstack: Vec&lt;Frame&gt;,
    /// value stack
    vstack: Vec&lt;Value&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#hooks" id="hooks">Hooks</a></h1>
<h2><a class="header" href="#load-hook" id="load-hook">Load Hook</a></h2>
<p><code>vm.set_load_hook(callback)</code></p>
<p>The load hook is a special function bound to the <code>Vm</code> that will be consulted first whenever a module should be loaded into the <code>Context</code>. It returns an <code>Option</code> containing the module if the hook is able to resolve the requested name.</p>
<h2><a class="header" href="#import-hook" id="import-hook">Import Hook</a></h2>
<p><code>vm.set_import_hook(callback)</code></p>
<p>The import hook handles the naming of functions being imported into the scope. As such it can also be used to adjust the naming scheme of the <code>lovm2</code> standard library.</p>
<h1><a class="header" href="#interrupt" id="interrupt">Interrupt</a></h1>
<p><code>vm.set_interrupt(n, callback)</code></p>
<p>Interrupts are more like a runtime extension of the bytecode. You can use this to implement optional extensions and frequently used functions without the overhead of a name lookup.</p>
<p>The test environment uses <code>Interrupt(10)</code> to analyse the programs state at a certain point of execution.</p>
<table><thead><tr><th align="center">Range</th><th align="center">Meaning</th></tr></thead><tbody>
<tr><td align="center">0 - 9</td><td align="center"><em>reserved</em></td></tr>
<tr><td align="center">10</td><td align="center">debug</td></tr>
<tr><td align="center">11 - 63</td><td align="center"><em>reserved</em></td></tr>
<tr><td align="center">64 - 255</td><td align="center"><em>free</em></td></tr>
</tbody></table>
<h1><a class="header" href="#examples" id="examples">Examples</a></h1>
<h2><a class="header" href="#projects" id="projects">Projects</a></h2>
<ul>
<li><a href="https://github.com/lausek/lol">lol - a lisp language</a></li>
<li><a href="https://github.com/witling/quasicode">quasicode - the best language around</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
