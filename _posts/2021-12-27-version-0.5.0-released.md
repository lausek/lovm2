---
layout: post
---

[Pull-Request](https://github.com/lausek/lovm2/pull/31)

## Changelog

- The previous scope determination of variables was clunky and unreliable. With the new API you are now able to explicitly set a variables scope to `local` (default) or `global`.

```rust
// old
block.step(Assign::local(l, ...));
block.step(Assign::global(g, ...));

// new
block.assign(l, ...);
block.global(g).assign(g, ...);
```

Note that the scope of a variable can be changed inside a block:

```rust
// change scope of shadow to global
block.global(shadow);
block.assign(shadow, "global");
// change scope of shadow to local again
block.local(shadow);
// this assigns a local variable now
block.assign(shadow, "local");
```

- Pretty much all exported names have been prefixed with `LV2` or `lv2_*` in order to avoid name collisions with vendor libraries (e.g. `Expr -> LV2Expr`). Module builder and VM creation also changed:

```rust
let builder = LV2ModuleBuilder::new();
...
let vm = LV2Vm::new();
```

- `HIR` was renamed to the much more logical `LV2Function`.

- Expressions are now constructed using a fluent interface:

```rust
// old
Expr::eq(Expr::rem(1, 2), 0)

// new
LV2Expr::from(1).rem(2).eq(0)
```

- Every expression can be boxed now (i.e. turned into a reference counted object to allow shared modifications):

```rust
LV2Expr::from(true).boxed()
```

- A lot of exported constructs like `Break`, `Continue`, `Return` are now methods on `LV2Block` instead of own structures.

```rust
// old
block.step(Break::new());
block.step(Continue::new());
block.step(Return::value(...));
block.step(Return::nil());
block.step(Interrupt::new(10));

// new
block.break_repeat();
block.continue_repeat();
block.return_value(...);
block.return_nil();
block.trigger(10); // trigger an interrupt
```

- `Abs` instruction for stripping the sign of a number.

- Code cleanup and improvements to the documentation.
